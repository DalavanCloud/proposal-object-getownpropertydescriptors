var fs = require("fs");
var path = require("path");
var os = require("os");
var core_1 = require("./core");
var diagnostics_1 = require("./diagnostics");
var options_1 = require("./options");
var tokens_1 = require("./tokens");
var parser_1 = require("./parser");
var binder_1 = require("./binder");
var checker_1 = require("./checker");
var index_1 = require("./emitter/index");
var Grammar = (function () {
    function Grammar(rootNames, options, readFile) {
        if (options === void 0) { options = options_1.getDefaultOptions(); }
        this.rootFiles = [];
        this.sourceFiles = [];
        this.diagnostics = new diagnostics_1.DiagnosticMessages();
        this.bindings = new binder_1.BindingTable();
        this.fileMap = new core_1.Dict();
        var platform = os.platform();
        this.ignoreCase = /^(win32|win64|darwin)$/.test(platform);
        this.innerReadFile = readFile;
        this.options = options;
        for (var _i = 0; _i < rootNames.length; _i++) {
            var rootName = rootNames[_i];
            this.processRootFile(this.resolveFile(rootName));
        }
        Object.freeze(this.sourceFiles);
    }
    Object.defineProperty(Grammar.prototype, "parser", {
        get: function () {
            if (!this.innerParser) {
                this.innerParser = this.createParser(this.options);
            }
            return this.innerParser;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "binder", {
        get: function () {
            if (!this.innerBinder) {
                this.innerBinder = this.createBinder(this.options, this.bindings);
            }
            return this.innerBinder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "checker", {
        get: function () {
            if (!this.innerChecker) {
                this.innerChecker = this.createChecker(this.options, this.bindings);
            }
            return this.innerChecker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grammar.prototype, "emitter", {
        get: function () {
            if (!this.innerEmitter) {
                this.innerEmitter = this.createEmitter(this.options, this.checker.resolver);
            }
            return this.innerEmitter;
        },
        enumerable: true,
        configurable: true
    });
    Grammar.prototype.getSourceFile = function (file) {
        file = this.resolveFile(file);
        return core_1.Dict.get(this.fileMap, this.normalizeFile(file));
    };
    Grammar.prototype.bind = function (sourceFile) {
        var binder = this.binder;
        if (sourceFile) {
            binder.bindSourceFile(sourceFile);
        }
        else {
            for (var _i = 0, _a = this.sourceFiles; _i < _a.length; _i++) {
                var sourceFile_1 = _a[_i];
                binder.bindSourceFile(sourceFile_1);
            }
        }
    };
    Grammar.prototype.check = function (sourceFile) {
        this.bind(sourceFile);
        var checker = this.checker;
        if (sourceFile) {
            checker.checkSourceFile(sourceFile);
        }
        else {
            for (var _i = 0, _a = this.sourceFiles; _i < _a.length; _i++) {
                var sourceFile_2 = _a[_i];
                checker.checkSourceFile(sourceFile_2);
            }
        }
    };
    Grammar.prototype.resetEmitter = function () {
        this.innerEmitter = undefined;
    };
    Grammar.prototype.emit = function (sourceFile, writeFile) {
        this.bind(sourceFile);
        this.check(sourceFile);
        var emitter = this.emitter;
        if (sourceFile) {
            emitter.emit(sourceFile, writeFile);
        }
        else {
            for (var _i = 0, _a = this.rootFiles; _i < _a.length; _i++) {
                var sourceFile_3 = _a[_i];
                emitter.emit(sourceFile_3, writeFile);
            }
        }
    };
    Grammar.prototype.createParser = function (options) {
        return new parser_1.Parser(this.diagnostics);
    };
    Grammar.prototype.createBinder = function (options, bindings) {
        return new binder_1.Binder(bindings);
    };
    Grammar.prototype.createChecker = function (options, bindings) {
        return new checker_1.Checker(bindings, options.noChecks ? diagnostics_1.NullDiagnosticMessages.instance : this.diagnostics);
    };
    Grammar.prototype.createEmitter = function (options, resolver) {
        switch (options.format) {
            case options_1.EmitFormat.ecmarkup:
                return new index_1.EcmarkupEmitter(options, resolver, this.diagnostics);
            case options_1.EmitFormat.html:
                return new index_1.HtmlEmitter(options, resolver, this.diagnostics);
            case options_1.EmitFormat.markdown:
            default:
                return new index_1.MarkdownEmitter(options, resolver, this.diagnostics);
        }
    };
    Grammar.prototype.readFile = function (file) {
        try {
            var callback = this.innerReadFile;
            if (callback) {
                return callback(file);
            }
            return readFile(file);
        }
        catch (e) {
            // report error
            return undefined;
        }
    };
    Grammar.prototype.resolveFile = function (file, referer) {
        var result;
        if (referer) {
            result = path.resolve(path.dirname(referer), file);
        }
        else {
            result = path.resolve(file);
        }
        result = result.replace(/\\/g, "/");
        return result;
    };
    Grammar.prototype.normalizeFile = function (file) {
        return this.ignoreCase ? file.toLowerCase() : file;
    };
    Grammar.prototype.processRootFile = function (file) {
        var sourceFile = this.processFile(file);
        if (this.rootFiles.indexOf(sourceFile) === -1) {
            this.rootFiles.push(sourceFile);
        }
    };
    Grammar.prototype.processFile = function (file, referer, refererPos, refererEnd) {
        var sourceFile = this.getSourceFile(file);
        if (sourceFile) {
            return sourceFile;
        }
        else {
            sourceFile = this.parseSourceFile(file);
            if (sourceFile) {
                core_1.Dict.set(this.fileMap, this.normalizeFile(file), sourceFile);
                this.sourceFiles.push(sourceFile);
                this.processImports(sourceFile, file);
            }
        }
        return sourceFile;
    };
    Grammar.prototype.processImports = function (sourceFile, refererName) {
        for (var _i = 0, _a = sourceFile.elements; _i < _a.length; _i++) {
            var element = _a[_i];
            if (element.kind === tokens_1.SyntaxKind.Import) {
                var importNode = element;
                if (importNode.path) {
                    var importPath = this.resolveFile(importNode.path.text, refererName);
                    this.processFile(importPath, sourceFile, importNode.pos, importNode.end);
                }
            }
        }
    };
    Grammar.prototype.parseSourceFile = function (file) {
        if (!this.parser) {
            this.parser = new parser_1.Parser(this.diagnostics);
        }
        var sourceText = this.readFile(file);
        if (sourceText !== undefined) {
            return this.parser.parseSourceFile(file, sourceText);
        }
        return undefined;
    };
    return Grammar;
})();
exports.Grammar = Grammar;
function readFile(file) {
    return fs.readFileSync(file, "utf8");
}

//# sourceMappingURL=grammar.js.map
