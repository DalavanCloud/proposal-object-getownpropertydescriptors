var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var diagnostics_1 = require("./diagnostics");
var tokens_1 = require("./tokens");
var nextNodeId = 0;
var Node = (function () {
    function Node(kind) {
        this.id = ++nextNodeId;
        this.kind = kind;
    }
    return Node;
})();
exports.Node = Node;
var StringLiteral = (function (_super) {
    __extends(StringLiteral, _super);
    function StringLiteral(text) {
        _super.call(this, tokens_1.SyntaxKind.StringLiteral);
        this.text = text;
    }
    return StringLiteral;
})(Node);
exports.StringLiteral = StringLiteral;
var Identifier = (function (_super) {
    __extends(Identifier, _super);
    function Identifier(text) {
        _super.call(this, tokens_1.SyntaxKind.Identifier);
        this.text = text;
    }
    return Identifier;
})(Node);
exports.Identifier = Identifier;
var LexicalSymbol = (function (_super) {
    __extends(LexicalSymbol, _super);
    function LexicalSymbol() {
        _super.apply(this, arguments);
    }
    return LexicalSymbol;
})(Node);
exports.LexicalSymbol = LexicalSymbol;
var PrimarySymbol = (function (_super) {
    __extends(PrimarySymbol, _super);
    function PrimarySymbol() {
        _super.apply(this, arguments);
    }
    return PrimarySymbol;
})(LexicalSymbol);
exports.PrimarySymbol = PrimarySymbol;
var OptionalSymbol = (function (_super) {
    __extends(OptionalSymbol, _super);
    function OptionalSymbol(kind, questionToken) {
        _super.call(this, kind);
        this.questionToken = questionToken;
    }
    return OptionalSymbol;
})(PrimarySymbol);
exports.OptionalSymbol = OptionalSymbol;
var UnicodeCharacterLiteral = (function (_super) {
    __extends(UnicodeCharacterLiteral, _super);
    function UnicodeCharacterLiteral(text, questionToken) {
        _super.call(this, tokens_1.SyntaxKind.UnicodeCharacterLiteral, questionToken);
        this.text = text;
    }
    return UnicodeCharacterLiteral;
})(OptionalSymbol);
exports.UnicodeCharacterLiteral = UnicodeCharacterLiteral;
var UnicodeCharacterRange = (function (_super) {
    __extends(UnicodeCharacterRange, _super);
    function UnicodeCharacterRange(left, throughKeyword, right) {
        _super.call(this, tokens_1.SyntaxKind.UnicodeCharacterRange);
        this.left = left;
        this.throughKeyword = throughKeyword;
        this.right = right;
    }
    return UnicodeCharacterRange;
})(LexicalSymbol);
exports.UnicodeCharacterRange = UnicodeCharacterRange;
var ButNotSymbol = (function (_super) {
    __extends(ButNotSymbol, _super);
    function ButNotSymbol(left, butKeyword, notKeyword, right) {
        _super.call(this, tokens_1.SyntaxKind.ButNotSymbol);
        this.left = left;
        this.butKeyword = butKeyword;
        this.notKeyword = notKeyword;
        this.right = right;
    }
    return ButNotSymbol;
})(LexicalSymbol);
exports.ButNotSymbol = ButNotSymbol;
var Terminal = (function (_super) {
    __extends(Terminal, _super);
    function Terminal(text, questionToken) {
        _super.call(this, tokens_1.SyntaxKind.Terminal, questionToken);
        this.text = text;
    }
    return Terminal;
})(OptionalSymbol);
exports.Terminal = Terminal;
var TerminalList = (function (_super) {
    __extends(TerminalList, _super);
    function TerminalList(terminals) {
        if (terminals === void 0) { terminals = []; }
        _super.call(this, tokens_1.SyntaxKind.TerminalList);
        this.terminals = terminals;
    }
    return TerminalList;
})(Node);
exports.TerminalList = TerminalList;
var SymbolSet = (function (_super) {
    __extends(SymbolSet, _super);
    function SymbolSet(openBraceToken, elements, closeBraceToken) {
        _super.call(this, tokens_1.SyntaxKind.SymbolSet);
        this.openBraceToken = openBraceToken;
        this.elements = elements;
        this.closeBraceToken = closeBraceToken;
    }
    return SymbolSet;
})(Node);
exports.SymbolSet = SymbolSet;
var Assertion = (function (_super) {
    __extends(Assertion, _super);
    function Assertion(kind, openBracketToken, closeBracketToken) {
        _super.call(this, kind);
        this.openBracketToken = openBracketToken;
        this.closeBracketToken = closeBracketToken;
    }
    return Assertion;
})(LexicalSymbol);
exports.Assertion = Assertion;
var EmptyAssertion = (function (_super) {
    __extends(EmptyAssertion, _super);
    function EmptyAssertion(openBracketToken, emptyKeyword, closeBracketToken) {
        _super.call(this, tokens_1.SyntaxKind.EmptyAssertion, openBracketToken, closeBracketToken);
        this.emptyKeyword = emptyKeyword;
    }
    return EmptyAssertion;
})(Assertion);
exports.EmptyAssertion = EmptyAssertion;
var LookaheadAssertion = (function (_super) {
    __extends(LookaheadAssertion, _super);
    function LookaheadAssertion(openBracketToken, lookaheadKeyword, operatorToken, lookahead, closeBracketToken) {
        _super.call(this, tokens_1.SyntaxKind.LookaheadAssertion, openBracketToken, closeBracketToken);
        this.lookaheadKeyword = lookaheadKeyword;
        this.operatorToken = operatorToken;
        this.lookahead = lookahead;
    }
    return LookaheadAssertion;
})(Assertion);
exports.LookaheadAssertion = LookaheadAssertion;
var LexicalGoalAssertion = (function (_super) {
    __extends(LexicalGoalAssertion, _super);
    function LexicalGoalAssertion(openBracketToken, lexicalKeyword, goalKeyword, symbol, closeBracketToken) {
        _super.call(this, tokens_1.SyntaxKind.LexicalGoalAssertion, openBracketToken, closeBracketToken);
        this.lexicalKeyword = lexicalKeyword;
        this.goalKeyword = goalKeyword;
        this.symbol = symbol;
    }
    return LexicalGoalAssertion;
})(Assertion);
exports.LexicalGoalAssertion = LexicalGoalAssertion;
var NoSymbolHereAssertion = (function (_super) {
    __extends(NoSymbolHereAssertion, _super);
    function NoSymbolHereAssertion(openBracketToken, noKeyword, symbols, hereKeyword, closeBracketToken) {
        _super.call(this, tokens_1.SyntaxKind.NoSymbolHereAssertion, openBracketToken, closeBracketToken);
        this.noKeyword = noKeyword;
        this.symbols = symbols;
        this.hereKeyword = hereKeyword;
    }
    return NoSymbolHereAssertion;
})(Assertion);
exports.NoSymbolHereAssertion = NoSymbolHereAssertion;
var ParameterValueAssertion = (function (_super) {
    __extends(ParameterValueAssertion, _super);
    function ParameterValueAssertion(openBracketToken, operatorToken, name, closeBracketToken) {
        _super.call(this, tokens_1.SyntaxKind.ParameterValueAssertion, openBracketToken, closeBracketToken);
        this.operatorToken = operatorToken;
        this.name = name;
    }
    return ParameterValueAssertion;
})(Assertion);
exports.ParameterValueAssertion = ParameterValueAssertion;
var Argument = (function (_super) {
    __extends(Argument, _super);
    function Argument(questionToken, name) {
        _super.call(this, tokens_1.SyntaxKind.Argument);
        this.questionToken = questionToken;
        this.name = name;
    }
    return Argument;
})(Node);
exports.Argument = Argument;
var ArgumentList = (function (_super) {
    __extends(ArgumentList, _super);
    function ArgumentList(openParenToken, elements, closeParenToken) {
        _super.call(this, tokens_1.SyntaxKind.ArgumentList);
        this.openParenToken = openParenToken;
        this.elements = elements;
        this.closeParenToken = closeParenToken;
    }
    return ArgumentList;
})(Node);
exports.ArgumentList = ArgumentList;
var Nonterminal = (function (_super) {
    __extends(Nonterminal, _super);
    function Nonterminal(name, argumentList, questionToken) {
        _super.call(this, tokens_1.SyntaxKind.Nonterminal, questionToken);
        this.name = name;
        this.argumentList = argumentList;
    }
    return Nonterminal;
})(OptionalSymbol);
exports.Nonterminal = Nonterminal;
var Prose = (function (_super) {
    __extends(Prose, _super);
    function Prose(text) {
        _super.call(this, tokens_1.SyntaxKind.Prose);
        this.text = text;
    }
    return Prose;
})(LexicalSymbol);
exports.Prose = Prose;
var OneOfSymbol = (function (_super) {
    __extends(OneOfSymbol, _super);
    function OneOfSymbol(oneKeyword, ofKeyword, symbols) {
        _super.call(this, tokens_1.SyntaxKind.OneOfSymbol);
        this.oneKeyword = oneKeyword;
        this.ofKeyword = ofKeyword;
        this.symbols = symbols;
    }
    return OneOfSymbol;
})(LexicalSymbol);
exports.OneOfSymbol = OneOfSymbol;
var SymbolSpan = (function (_super) {
    __extends(SymbolSpan, _super);
    function SymbolSpan(symbol, next) {
        _super.call(this, tokens_1.SyntaxKind.SymbolSpan);
        this.symbol = symbol;
        this.next = next;
    }
    return SymbolSpan;
})(Node);
exports.SymbolSpan = SymbolSpan;
var LinkReference = (function (_super) {
    __extends(LinkReference, _super);
    function LinkReference(text) {
        _super.call(this, tokens_1.SyntaxKind.LinkReference);
        this.text = text;
    }
    return LinkReference;
})(Node);
exports.LinkReference = LinkReference;
var RightHandSide = (function (_super) {
    __extends(RightHandSide, _super);
    function RightHandSide(head, reference) {
        _super.call(this, tokens_1.SyntaxKind.RightHandSide);
        this.head = head;
        this.reference = reference;
    }
    return RightHandSide;
})(Node);
exports.RightHandSide = RightHandSide;
var RightHandSideList = (function (_super) {
    __extends(RightHandSideList, _super);
    function RightHandSideList(openIndentToken, elements, closeIndentToken) {
        _super.call(this, tokens_1.SyntaxKind.RightHandSideList);
        this.openIndentToken = openIndentToken;
        this.elements = elements;
        this.closeIndentToken = closeIndentToken;
    }
    return RightHandSideList;
})(Node);
exports.RightHandSideList = RightHandSideList;
var OneOfList = (function (_super) {
    __extends(OneOfList, _super);
    function OneOfList(oneKeyword, ofKeyword, openIndentToken, terminals, closeIndentToken) {
        _super.call(this, tokens_1.SyntaxKind.OneOfList);
        this.oneKeyword = oneKeyword;
        this.ofKeyword = ofKeyword;
        this.openIndentToken = openIndentToken;
        this.terminals = terminals;
        this.closeIndentToken = closeIndentToken;
    }
    return OneOfList;
})(Node);
exports.OneOfList = OneOfList;
var Parameter = (function (_super) {
    __extends(Parameter, _super);
    function Parameter(name) {
        _super.call(this, tokens_1.SyntaxKind.Parameter);
        this.name = name;
    }
    return Parameter;
})(Node);
exports.Parameter = Parameter;
var ParameterList = (function (_super) {
    __extends(ParameterList, _super);
    function ParameterList(openParenToken, elements, closeParenToken) {
        _super.call(this, tokens_1.SyntaxKind.ParameterList);
        this.openParenToken = openParenToken;
        this.elements = elements;
        this.closeParenToken = closeParenToken;
    }
    return ParameterList;
})(Node);
exports.ParameterList = ParameterList;
var SourceElement = (function (_super) {
    __extends(SourceElement, _super);
    function SourceElement() {
        _super.apply(this, arguments);
    }
    return SourceElement;
})(Node);
exports.SourceElement = SourceElement;
var Production = (function (_super) {
    __extends(Production, _super);
    function Production(name, parameters, colonToken, body) {
        _super.call(this, tokens_1.SyntaxKind.Production);
        this.name = name;
        this.parameterList = parameters;
        this.colonToken = colonToken;
        this.body = body;
    }
    return Production;
})(SourceElement);
exports.Production = Production;
var Import = (function (_super) {
    __extends(Import, _super);
    function Import(atToken, importKeyword, path) {
        _super.call(this, tokens_1.SyntaxKind.Import);
        this.atToken = atToken;
        this.importKeyword = importKeyword;
        this.path = path;
    }
    return Import;
})(SourceElement);
exports.Import = Import;
var SourceFile = (function (_super) {
    __extends(SourceFile, _super);
    function SourceFile(filename, text) {
        _super.call(this, tokens_1.SyntaxKind.SourceFile);
        this.filename = filename;
        this.text = text;
        this.lineMap = new diagnostics_1.LineMap(text);
        this.pos = 0;
        this.end = this.text.length;
    }
    return SourceFile;
})(Node);
exports.SourceFile = SourceFile;
function visitNode(node, cbNode) {
    if (node) {
        return cbNode(node);
    }
    return undefined;
}
function visitNodes(nodes, cbNode) {
    if (nodes) {
        var result;
        for (var i = 0; i < nodes.length; i++) {
            result = visitNode(nodes[i], cbNode);
            if (result) {
                return result;
            }
        }
    }
    return undefined;
}
function forEachChild(node, cbNode) {
    if (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.TerminalList:
                return visitNodes(node.terminals, cbNode);
            case tokens_1.SyntaxKind.SymbolSet:
                return visitNode(node.openBraceToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeBraceToken, cbNode);
            case tokens_1.SyntaxKind.EmptyAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.emptyKeyword, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.LookaheadAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.lookaheadKeyword, cbNode)
                    || visitNode(node.operatorToken, cbNode)
                    || visitNode(node.lookahead, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.lexicalKeyword, cbNode)
                    || visitNode(node.goalKeyword, cbNode)
                    || visitNode(node.symbol, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.noKeyword, cbNode)
                    || visitNodes(node.symbols, cbNode)
                    || visitNode(node.hereKeyword, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.operatorToken, cbNode)
                    || visitNode(node.name, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.InvalidAssertion:
                return visitNode(node.openBracketToken, cbNode)
                    || visitNode(node.closeBracketToken, cbNode);
            case tokens_1.SyntaxKind.Terminal:
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                return visitNode(node.questionToken, cbNode);
            case tokens_1.SyntaxKind.Nonterminal:
                return visitNode(node.name, cbNode)
                    || visitNode(node.argumentList, cbNode)
                    || visitNode(node.questionToken, cbNode);
            case tokens_1.SyntaxKind.OneOfSymbol:
                return visitNodes(node.symbols, cbNode);
            case tokens_1.SyntaxKind.ButNotSymbol:
                return visitNode(node.left, cbNode)
                    || visitNode(node.butKeyword, cbNode)
                    || visitNode(node.notKeyword, cbNode)
                    || visitNode(node.right, cbNode);
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                return visitNode(node.left, cbNode)
                    || visitNode(node.throughKeyword, cbNode)
                    || visitNode(node.right, cbNode);
            case tokens_1.SyntaxKind.SymbolSpan:
                return visitNode(node.symbol, cbNode)
                    || visitNode(node.next, cbNode);
            case tokens_1.SyntaxKind.RightHandSide:
                return visitNode(node.head, cbNode)
                    || visitNode(node.reference, cbNode);
            case tokens_1.SyntaxKind.RightHandSideList:
                return visitNode(node.openIndentToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeIndentToken, cbNode);
            case tokens_1.SyntaxKind.OneOfList:
                return visitNode(node.oneKeyword, cbNode)
                    || visitNode(node.ofKeyword, cbNode)
                    || visitNode(node.openIndentToken, cbNode)
                    || visitNodes(node.terminals, cbNode)
                    || visitNode(node.closeIndentToken, cbNode);
            case tokens_1.SyntaxKind.Parameter:
                return visitNode(node.name, cbNode);
            case tokens_1.SyntaxKind.ParameterList:
                return visitNode(node.openParenToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeParenToken, cbNode);
            case tokens_1.SyntaxKind.Argument:
                return visitNode(node.questionToken, cbNode)
                    || visitNode(node.name, cbNode);
            case tokens_1.SyntaxKind.ArgumentList:
                return visitNode(node.openParenToken, cbNode)
                    || visitNodes(node.elements, cbNode)
                    || visitNode(node.closeParenToken, cbNode);
            case tokens_1.SyntaxKind.Production:
                return visitNode(node.name, cbNode)
                    || visitNode(node.parameterList, cbNode)
                    || visitNode(node.body, cbNode);
            case tokens_1.SyntaxKind.Import:
                return visitNode(node.atToken, cbNode)
                    || visitNode(node.importKeyword, cbNode)
                    || visitNode(node.path, cbNode);
            case tokens_1.SyntaxKind.SourceFile:
                return visitNodes(node.elements, cbNode);
        }
    }
    return undefined;
}
exports.forEachChild = forEachChild;

//# sourceMappingURL=nodes.js.map
