var fs = require("fs");
var path = require("path");
var stringwriter_1 = require("../stringwriter");
var tokens_1 = require("../tokens");
var nodes_1 = require("../nodes");
var Emitter = (function () {
    function Emitter(options, resolver, diagnostics) {
        this.options = options;
        this.resolver = resolver;
        this.diagnostics = diagnostics;
    }
    Emitter.prototype.emit = function (node, writeFile) {
        var saveWriter = this.writer;
        try {
            this.writer = this.createWriter();
            this.emitNode(node);
            var file = this.getOutputFilename(node);
            var text = this.writer.toString();
            this.writeFile(file, text, writeFile);
        }
        finally {
            this.writer = saveWriter;
        }
    };
    Emitter.prototype.writeFile = function (file, text, callback) {
        if (callback) {
            callback(file, text);
        }
        else {
            writeOutputFile(file, text);
        }
    };
    Emitter.prototype.getOutputFilename = function (node) {
        var parsed;
        var extension = this.extension || ".out";
        if (this.options.out) {
            return this.options.out;
        }
        else {
            var dirname = path.dirname(node.filename);
            var basename = path.basename(node.filename, ".grammar");
            return path.join(dirname, basename + extension);
        }
    };
    Emitter.prototype.createWriter = function () {
        return new stringwriter_1.StringWriter();
    };
    Emitter.prototype.emitNode = function (node) {
        if (!node) {
            return;
        }
        switch (node.kind) {
            case tokens_1.SyntaxKind.SourceFile:
                this.emitSourceFile(node);
                break;
            case tokens_1.SyntaxKind.AtToken:
                this.emitPlaceholder(node);
                break;
            case tokens_1.SyntaxKind.Terminal:
                this.emitTerminal(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.emitUnicodeCharacterLiteral(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.emitUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.Prose:
                this.emitProse(node);
                break;
            case tokens_1.SyntaxKind.Identifier:
                this.emitIdentifier(node);
                break;
            case tokens_1.SyntaxKind.Parameter:
                this.emitParameter(node);
                break;
            case tokens_1.SyntaxKind.ParameterList:
                this.emitParameterList(node);
                break;
            case tokens_1.SyntaxKind.Argument:
                this.emitArgument(node);
                break;
            case tokens_1.SyntaxKind.ArgumentList:
                this.emitArgumentList(node);
                break;
            case tokens_1.SyntaxKind.Production:
                this.emitProduction(node);
                break;
            case tokens_1.SyntaxKind.Import:
                this.emitImport(node);
                break;
            case tokens_1.SyntaxKind.OneOfList:
                this.emitOneOfList(node);
                break;
            case tokens_1.SyntaxKind.RightHandSideList:
                this.emitRightHandSideList(node);
                break;
            case tokens_1.SyntaxKind.RightHandSide:
                this.emitRightHandSide(node);
                break;
            case tokens_1.SyntaxKind.SymbolSpan:
                this.emitSymbolSpan(node);
                break;
            case tokens_1.SyntaxKind.ThroughKeyword:
                this.emitKeyword(node);
                break;
            case tokens_1.SyntaxKind.ButNotSymbol:
                this.emitButNotSymbol(node);
                break;
            case tokens_1.SyntaxKind.OneOfSymbol:
                this.emitOneOfSymbol(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.emitNonterminal(node);
                break;
            case tokens_1.SyntaxKind.TerminalList:
                this.emitTerminalList(node);
                break;
            case tokens_1.SyntaxKind.SymbolSet:
                this.emitSymbolSet(node);
                break;
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.emitEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.emitLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.emitLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.emitNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                this.emitParameterValueAssertion(node);
                break;
        }
    };
    Emitter.prototype.emitSourceFile = function (node) {
        for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
            var element = _a[_i];
            this.emitNode(element);
        }
    };
    Emitter.prototype.emitKeyword = function (node) {
        this.emitToken(node);
    };
    Emitter.prototype.emitToken = function (node) {
        if (node) {
            this.writer.write(tokens_1.tokenToString(node.kind));
        }
    };
    Emitter.prototype.emitPlaceholder = function (node) {
        this.emitToken(node);
    };
    Emitter.prototype.emitTerminal = function (node) {
        this.emitTextContent(node);
        this.emitNode(node.questionToken);
    };
    Emitter.prototype.emitUnicodeCharacterLiteral = function (node) {
        this.emitTextContent(node);
        this.emitNode(node.questionToken);
    };
    Emitter.prototype.emitTextContent = function (node) {
        this.writer.write(node.text);
    };
    Emitter.prototype.emitProse = function (node) {
        this.emitTextContent(node);
    };
    Emitter.prototype.emitIdentifier = function (node) {
        this.emitTextContent(node);
    };
    Emitter.prototype.emitParameter = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitParameterList = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitArgument = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitArgumentList = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitProduction = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitImport = function (node) {
    };
    Emitter.prototype.emitOneOfList = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitRightHandSideList = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitRightHandSide = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitSymbolSpan = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitUnicodeCharacterRange = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitButNotSymbol = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitOneOfSymbol = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitNonterminal = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitTerminalList = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitSymbolSet = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitEmptyAssertion = function (node) {
    };
    Emitter.prototype.emitLookaheadAssertion = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitLexicalGoalAssertion = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitNoSymbolHereAssertion = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.emitParameterValueAssertion = function (node) {
        var _this = this;
        nodes_1.forEachChild(node, function (child) { return _this.emitNode(child); });
    };
    Emitter.prototype.encode = function (text) {
        return text.replace(/[&<>'"]/g, function (ch) {
            switch (ch) {
                case "&": return "&amp;";
                case "<": return "&lt;";
                case ">": return "&gt;";
                case "'": return "&apos;";
                case '"': return "&quot;";
            }
        });
    };
    return Emitter;
})();
exports.Emitter = Emitter;
function writeOutputFile(file, text) {
    fs.writeFileSync(file, text, "utf8");
}

//# sourceMappingURL=emitter.js.map
